- 1. c/c++（36）
	- 1.1 语言
		- #card #问题集V1 1.1.1 static、const 作用
		  collapsed:: true
			- {{query 关键字static的作用}}
			- {{query 关键字const}}
		- #card #问题集V1 1.1.2 引用与指针作用以及区别？
			- 作用
				- C++ 的发明人 比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup） 说过，他在 C++ 中引入引用的直接目的是为了让代码的书写更加漂亮，尤其是在运算符重载中，不借助引用有时候会使得运算符的使用很麻烦。
				- 指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
				- 引用基于指针实现，而指针的作用
					- 1.指针允许你以更简洁的方式引用大的数据结构
						- 程序的数据结构从原子级别的数据结构：整型、浮点型、字符型、枚举型，到分子级别的数组、结构体，再到数据结构中的队列、栈、链表、树等，无论如何复杂，数据结构总是位于计算机的内存中，因此必有地址。利用指针就可以使用地址作为一个完整值的速记符号，因为一个内存地址在内部表示为一个整数。当数据结构本身很大时，这种策略能节约大量内存空间
					- 2.指针使程序的不同部分能够共享数据
						- 类似于共享内存，如果将某一个数据值的地址从一个函数传递到另外一个函数，这两个函数就能使用同一数据。
					- 3.利用指针，能在程序执行过程中预留新的内存空间
						- 大多数情况下，可以看到程序使用的内存是通过显式声明分配给变量的内存（也就是静态内存分配）。这一点对于节省计算机内存是有帮助的，因为计算机可以提前为需要的变量分配内存。但是在很多应用场合中，可能程序运行时不清楚到底需要多少内存，这时候可以使用指针，让程序在运行时获得新的内存空间（实际上应该就是动态内存分配），并让指针指向这一内存更为方便。
					- 4.指针可以用来记录数据项之间的关系
						- 在高级程序设计应用中，指针被广泛应用于构造单个数据值之间的联系。比如，程序员通常在第一个数据的内部表示中包含指向下一个数据项的指针（实际上就是链表了），来说明这两个数据项之间有概念上的顺序关系。
					- 其它网上相关使用指针可以带来如下的好处：
					  （1）可以提高程序的编译效率和执行速度，使程序更加简洁。
					- （2）通过指针被调用函数可以向调用函数处返回除正常的返回值之外的其他数据，从而实现两者间的双向通信。
					- （3）利用指针可以实现动态内存分配。
					- （4）指针还用于表示和实现各种复杂的数据结构，从而为编写出更加高质量的程序奠定基础。
					- （5）利用指针可以直接操纵内存地址，从而可以完成和汇编语言类似的工作。
					- （6）更容易实现函数的编写和调用
			- 区别
				- 1、两者的定义和性质不同
				  collapsed:: true
					- 指针是一个^^变量^^，存储的是一个地址，指向内存的一个存储单元；
					- 引用是原变量的一个^^别名^^，跟原来的变量实质上是同一个东西。
					- ```c++
					  int a = 996;
					  int *p = &a; // p是指针, &在此是求地址运算
					  int &r = a; // r是引用, &在此起标识作用
					  ```
				- 2、指针可以有多级，引用只能是一级
				  collapsed:: true
					- ```c++
					  int **p; // 合法
					  int &&a; // 不合法
					  ```
				- 3、指针可以在定义的时候不初始化，引用必须在定义的时候初始化
				  collapsed:: true
					- ```c++
					  int *p; // 合法
					  int &r; // 不合法
					  int a = 996;
					  int &r = a; // 合法
					  ```
				- 4、指针可以指向NULL，引用不可以为NULL
				  collapsed:: true
					- ```c++
					  int *p = NULL; // 合法
					  int &r = NULL; // 不合法
					  ```
				- 5、指针初始化之后可以再改变，引用不可以
				  collapsed:: true
					- ```c++
					  int a = 996;
					  int *p = &a; // 初始化, p 是 a 的地址
					  int &r = a; // 初始化, r 是 a 的引用
					  
					  int b = 885;
					  p = &b;	// 合法, p 更改为 b 的地址
					  r = b; 	// 不合法, r 不可以再变
					  ```
				- 6、sizeof 的运算结果不同
				  collapsed:: true
					- ```c++
					  int a = 996;
					  int *p = &a;
					  int &r = a;
					  
					  cout << sizeof(p); // 返回 int* 类型的大小
					  cout << sizeof(r); // 返回 int 类型的大小
					  ```
				- 7、自增运算意义不同
				  collapsed:: true
					- ```c++
					  int a = 996;
					  int *p = &a;
					  int &r = a;
					  
					  p++;//p++之后指向a后面的内存
					  r++;//r++相当于a++
					  ```
				- 8、指针和引用作为函数参数时，指针需要检查是否为空，引用不需要
				  collapsed:: true
					- ```c++
					  void fun_p(int *p)
					  {
					      // 需要检查P是否为空
					      if (p == NULL) 
					      {
					          // do something
					      }
					  }
					  
					  void fun_r(int &r)
					  {
					      // 不需要检查r
					      // do something
					  }
					  ```
		- 1.1.3 如何避免野指针？
		- 1.1.4 malloc、free 和 new、delete 区别？malloc 申请空间失败怎么办？
		- 1.1.5 extern 有什么作用？
		- 1.1.6 简述 strcpy、sprintf 与 memcpy 的区别？
		- 1.1.7 c/c++ 中强制类型转换使用场景？
		- 1.1.8 什么时候生成默认构造函数？
		- 1.1.9 什么时候生产默认拷贝构造函数？
		- 1.1.10 什么是深拷贝？什么是浅拷贝？默认拷贝构造函数是哪种拷贝？什么时候用深拷贝？
	- 1.2 标准库
	  collapsed:: true
		- 1.2.1 vector 底层实现原理？
		  1.2.2 vector 内存增长机制？
		  1.2.3 vector 的 reserve 和 resize 的区别？
		  1.2.4 vector 的元素类型为什么不能是引用？
		  1.2.5 list 的底层实现原理
		  1.2.6 deque 的底层实现原理
		  1.2.7 什么时候使用 vector、list、以及 deque？
		  1.2.8 priority_queue 的底层实现原理
		  1.2.9 map、set、multimap、multiset 的底层实现原理？红黑树原理？
		  1.2.10 unordered_map、unordered_set 的底层实现原理？哈希表原理？
		  1.2.11 迭代器底层实现原理？以及有哪些种类？
		  1.2.12 迭代器失效？连续存储容器的失效？非连续存储容器的失效？以及分别的处
		  1.2.13 STL 容器的线程安全性
	- 1.3 面对对象
	  collapsed:: true
		- 1.3.1 面向对象的三大特征
		- 1.3.2 简述多态实现原理
		- 1.3.3 怎么解决菱形继承？
		- 1.3.4 函数重载和重写的区别？
		- 1.3.5 运行期多态的实现原理?
		- 1.3.6 虚函数的调用过程？
		- 1.3.7 继承下的构造函数和析构函数的执行顺序？
		- 1.3.8 虚函数表和虚函数表指针vptr的创建时机？
		- 1.3.9 虚析构函数的作用？
		- 1.3.10 智能指针各类及使用场景？
		- 1.3.11 c++ 11 用过哪些特性？
		- 1.3.12 动态库和静态库的区别
		- 1.3.13 左值引用与右值引用的区别？右值引用的意义？
- 2. 设计模式（14）
	- 2.1 设计原则
	  2.1.1 面对对象中有哪些设计原则？
	  2.1.2 简述开闭原则，哪些原则与它相关，分别是什么关系？
	  2.1.3 什么是里氏替换原则？
	  2.1.4 什么是迪米特原则？
	  2.1.5 什么是依赖倒置原则？
	- 2.2 创建型
	  2.2.1 单例模式多线程？
	  2.2.2 什么是工厂模式？什么是抽象工厂？应用场景是什么？
	- 2.3 结构型
	  2.3.1 什么是代理模式？应用场景是什么？
	  2.3.2 什么是装饰器模式？应用场景是什么？
	  2.3.3 什么是组合模式？应用场景是什么？
	  2.3.4 什么是责任链模式？应用场景是什么？
	- 2.4 行为型
	  2.4.1 什么是模版方法？应用场景是什么？
	  2.4.2 什么是策略模式？应用场景是什么？
	  2.4.3 什么是观察者模式？应用场景是什么？
- 3. 数据结构和算法（35）
	- 3.1 栈、队列
		- 3.1.1 用两个栈实现队列
		  3.1.2 包含 min 函数的栈
		  3.1.3 队列的最大值
		  3.1.4 用一个栈实现另一个栈的排序
		  3.1.5 如何仅用递归函数和栈操作逆序一个栈
	- 3.2 链表
		- 3.2.1 链表中倒数第 k 个节点？
		  3.2.2 链表中环的入口节点？
		  3.2.3 反转链表？
		  3.2.4 从尾到头打印链表
		  3.2.5 两个链表的第一个公共节点
	- 3.3 字符串
		- 3.3.1 第一个只出现一次的字符
		  3.3.2 最长不含重复字符的子字符串
		  3.3.3 字符串的排列
		  3.3.4 反转字符串
		  3.3.5 把数字翻译成字符串
	- 3.4 二叉树
		- 3.4.1 重建二叉树
		  3.4.2 二叉树的下一个节点
		  3.4.3 树的子结构
		  3.4.4 二叉树的镜像
		  3.4.5 对称的二叉树
		  3.4.6 从上到下打印二叉树
		  3.4.7 序列化二叉树
		  3.4.8 二叉树的深度
		  3.4.9 二叉树第 k 大节点
		  3.4.10 树中两个节点的最低公共祖先
	- 3.5 动态规划、贪心
		- 3.5.1 剪绳子
		  3.5.2 二进制中 1 的个数
		  3.5.3 矩阵的最小路径和
		  3.5.4 换钱的方法数
		  3.5.5 换钱的最少货币数
		  3.5.6 最长公共子序列问题
		  3.5.7 最长公共子串问题
		  3.5.8 数组中的最长连续序列
		  3.5.9 最长递增子序列
		  3.5.10 最小编辑代价
- 4. 操作系统（17）
	- 4.1 进程线程
		- 4.1.1 进程和线程的区别？
		  4.1.2 操作系统中进程与线程切换过程？
		  4.1.3 请描述整个系统调用过程？
		  4.1.4 后台进程有什么特点，如果要你设计一个进程是后台进程，需要考虑什么？
		  4.1.5 进程间通信有哪几种方式？
		  4.1.6 操作系统中进程调度策略有哪几种？
		  4.1.7 线程同步的方式？
		  4.1.8 CAS 是一种什么样的同步机制？
		  4.1.9 CPU 是怎么执行指令的？
	- 4.2 内存
		- 4.2.1 用户态和核心态的区别？
		  4.2.2 内存管理有哪几种方式？
		  4.2.3 分页和分段有什么区别?
		  4.2.4 页面置换算法有哪些？
		  4.2.5 什么是虚拟内存？
		  4.2.6 为什么虚拟地址空间切换会比较耗时？
		  4.2.7 虚拟内存和物理内存怎么对应？
		  4.2.8 请求页面置换策略有哪些方式？他们的区别是什么？各自有什么算法解决？
- 5. 数据库（32）
	- 5.1 mysql
		- 5.1.1 数据库三大范式？
		  5.1.2 MySQL cpu 飙升，该怎么处理？
		  5.1.3 如何定位以及优化 SQL 语句的性能问题？或者如何解决慢查询问题？
		  5.1.4 什么是视图？为什么要使用视图？
		  5.1.5 SQL 语句在 MySQL 是如何执行的？
		  5.1.6 索引在哪些情况下会失效？
		  5.1.7 索引的目的和代价分别是什么？
		  5.1.8 主键索引和唯一索引的区别？
		  5.1.9 聚集索引和非聚集索引的区别？
		  5.1.10 什么是覆盖索引？原理是什么？
		  5.1.11 什么是回表查询？原理是什么？
		  5.1.12 什么是最左匹配规则？原理是什么？
		  5.1.13 什么是索引下推？原理是什么?
		  5.1.14 InnoDB 与 MyISAM 的区别？
		- 5.1.15 索引为什么要用 B+ 树，而不是二叉树或者 B 树？
		  5.1.16 数据库事务的四个特性以及含义？
		  5.1.17 数据库的脏读，幻读，不可重复读出现的原因原理，解决办法？
		  5.1.18 不可重复读与幻读的区别？
		  5.1.19 SQL 注入原理？如何避免 SQL 注入？
		  5.1.20 MySQL 死锁问题产生的原因以及如何解决？
		- 5.1.21 MVCC 底层原理？
	- 5.2 redis
		- 5.2.1 什么是 redis？redis 的应用场景？
		  5.2.2 redis 的对象类型有哪些，底层实现用了哪些数据结构？
		  5.2.3 redis 中相同数量的数据，对比分别使用 hash 与 zset 存储的空间占用情
		  5.2.4 基于 redis 实现限流功能有哪几种方式？
		  5.2.5 redis 为什么是单线程？这里单线程指什么？为什么这么快？
		  5.2.6 redis 怎么实现分布式锁？有哪些缺陷？
		  5.2.7 redis 怎么做高可用？
		  5.2.8 redis 持久化有哪些，不同的持久化机制都有什么优缺点？
		  5.2.9 什么是缓存雪崩、缓存穿透、缓存击穿？分别有哪些解决方案？
		  5.2.10 redis 淘汰策略有哪些？
		  5.2.11 分析 redis 的事务？
- 6. 网络（15）
	- 6.1 网络编程
		- 6.1.1 简述 Reactor 网络编程模型？
		  6.1.2 比较 Reactor 和 Proactor 的区别？
		  6.1.3 连接断开有哪几种判定方式？
		  6.1.4 接收客户端连接有几种方式？
		  6.1.5 为什么用户态需要设置读写缓冲区？
	- 6.2 网络原理
		- 6.2.1 水平触发和边缘触发的区别？在边缘触发下，一个 socket 已读取 200 然后
		  6.2.2 CLOSE_WAIT 和 TIME_WAIT 是什么？如何排查？有什么意义？
		  6.2.3 TCP 三次握手的过程？为什么不可以是两次握手？
		  6.2.4 TCP 四次挥手的过程？TIME_WAIT 为什么至少设置两倍的 MSL 时间？
		  6.2.5 什么是连接的半打开，半关闭状态？
		  6.2.6 linux IO 模型有哪几种？简述 IO 多路复用机制？
		  6.2.7 阻塞 IO 和 非阻塞 IO 的区别？
		  6.2.8 select、poll、epoll 三者的区别？
		- 6.2.9 为什么边缘触发一定要用非阻塞 IO？
		  6.2.10 描述 IO 多路复用机制
- 7. 分布式和集群（44）
	- 7.1 分布式理论
		- 7.1.1 什么是 CAP 理论？
		  7.1.2 什么是 Base 理论？
		  7.1.3 什么是 2PC（两阶段提交）?
		  7.1.4 什么是 Raft 协议？ 解决了什么问题？
	- 7.2 kafka
		- 7.2.1 kafka 是什么？解决了什么问题？
		  7.2.2 zookeeper 对于 kafka 的作用是什么？
		  7.2.3 kafka 如何判断一个节点是否还活着？
		  7.2.4 简述 kafka 的 ack 三种机制？
		  7.2.5 如何控制消费的位置？
		  7.2.6 kafka 在分布式场景下，如何保证消息的顺序消费？
		  7.2.7 kafka 的高可用机制是什么？
		  7.2.8 kafka 如何减少数据丢失？
		  7.2.9 kafka 如何确保不消费重复数据？
		  7.2.10 kafka 如何维护消费状态的？
	- 7.3 gRPC
		- 7.3.1 gRPC 服务端启动流程？
		  7.3.2 gRPC 服务类型有哪些？
		  7.3.3 一个 connection 可以同时处理多个 stream，那 keepalive 是针对 stream 
		  7.3.4 多路复用指的是什么？
		  7.3.5 如何自定义 resolver？
		  7.3.6 如何自定义 balance？
		  7.3.7 如何实现 gRPC 全链路追踪？
		  7.3.8 客户端 connection 连接状态有哪些？
		  7.3.9 客户端如何获取服务端的服务函数列表？
		  7.3.10 gRPC 如何为每个 stream 进行限流？什么是 flow control？
	- 7.4 etcd
		- 7.4.1 etcd 中一个任期是什么意思？
		  7.4.2 etcd 中 raft 状态机是怎么样切换的？
		  7.4.3 如何防止 candidate 在遗漏部分数据的情况下发起投票成为 leader？
		  7.4.4 etcd 某个节点宕机后会怎么做？
		  7.4.5 为什么 Raft 算法在确定可用节点数量时不需要考虑拜占庭将军问题？
		  7.4.6 如何选举出 leader 节点？
		  7.4.7 怎么保证数据一致性？
	- 7.5 docker/k8s
		- 7.5.1 什么是 docker 镜像？
		  7.5.2 什么是 docker 容器？
		  7.5.3 docker 容器有几种状态？
		  7.5.4 DockerFile 中的命令 COPY 和 ADD 命令有什么区别?
		  7.5.5 容器与主机之间的数据拷贝命令?
		  7.5.6 解释一下 dockerfile 的 ONBUILD 指令?
		  7.5.7 如何在生产中监控 docker?
		  7.5.8 构建 docker 镜像应该遵循哪些原则?
		  7.5.9 容器退出后，通过 docker ps 命令查看不到，数据会丢失么?
	- 7.6 数据库集群
		- 7.6.1 MySQL 主从复制原理？
		  7.6.2 MySQL 分库分表？
		  7.6.3 简述 redis 高可用的方案？
		  7.6.4 简述 redis cluster 集群的原理？
- 8. 设计方案（7）
	- 8.1 发散题
		- 8.1.1 只用 2GB 内存在 20 亿个整数中找到出现次数最多的数
		  8.1.2 找到 100 亿个 URL 中重复的 URL 及搜索词汇的 Top K 问题
		  8.1.3 40亿个非负整数中找到未出现的数
		  8.1.4 40亿个非负整数中找到出现两次的数和所有数的中位数
		  8.1.5 岛问题
	- 8.2 综合题
		- 8.2.1 redis 和 mysql 缓存一致性
		- 8.2.2 设计一个海量定时器方案，时间跨度毫秒级到年
- 9. 其他