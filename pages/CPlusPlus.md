- {{cards [[CPlusPlus]] }}
- #card #CPlusPlus 什么函数不能被声明为虚函数
  template:: C++
	- 构造函数
- #card #CPlusPlus 引用与指针的区别：
	- {{query 引用与指针 }}
- #card #CPlusPlus 关键字static
	- c/c++共有
		- 1）：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。
		- 2）：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。
		- 3）：修饰函数时，表明该函数只能在同一文件中调用。
	- c++独有：
		- 4）：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有。
		- 5）：用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量
	- 深入理解
	  collapsed:: true
		- 静态局部变量的特点
			- 在全局数据区分配内存，非静态局部变量在（栈区）分配内存
			- 在程序执行到该对象处时只初始化一次，以后不再初始化；非静态局部变量每次都要初始化
			- 一般在声明处初始化，如果没有显示初始化，会被程序 自动初始化；非静态局部变量不会被 初始化
			- 始终驻留在全局数据区，直到程序运行结束，但其作用域为局部作用域；非静态局部变量在函数结束后立即释放
		- 静态全局变量的特点
			- 静态全局变量不能被其他文件使用；非静态全局变量可以
			- 其它文件中可以定义相同名字的变量，不会冲突；
		- 静态函数的特点
			- 静态函数 不能 被 其他文件使用
			- 其他文件中定义相同名字的函数不会冲突，static隔离
		- 静态成员函数的特点
			- 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数
			- 非静态成员函数可以任意地访问静态成员函数和静态成员函数
			- 静态成员函数不能访问非静态成员函数和非静态数据成员
			- 调用静态成员函数，可以用成员访问操作符（.）和（->）为一个类的对象或者指向类对象的指针调用静态成员函数，也可以用类名::函数名调用
			- 非静态数据成员，每个类对象都有自己的拷贝；静态数据成员被当作是类的成员，由该类的所有对象共享访问，对该类的多个对象来说，静态数据成员只分配一次内存
			- 静态数据成员存储在全局数据区。
			- 静态数据成员定义时要分配空间，所有不能在类声明中定义。
			-
	- 问题加深理解
		- （1）在头文件把一个变量申明为static变量，那么引用该头文件的源文件能够访问到该变量吗。
			- 可以。声明static变量一般是为了在本cpp文件中的static变量不能被其他的cpp文件引用，但是对于头文件，因为cpp文件中包含了头文件，故相当于该static变量在本cpp文件中也可以被见到。当多个cpp文件包含该头文件时，这个static变量将在各个cpp文件中都将是独立的，彼此修改不会对相互有影响。
		- （2）为什么静态成员函数不能申明为const
			- 这是C++的规则，const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall，而类中的static函数本质上是全局函数，调用规约是__cdecl或__stdcall,不能用const来修饰它。一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。而对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用const了
		- （3）为什么不能在类的内部定义以及初始化static成员变量，而必须要放到类的外部定义
			- 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。
		- （4）static关键字为什么只能出现在类内部的声明语句中，而不能重复出现在类外的定义中。
			- 如果类外定义函数时在函数名前加了static，因为作用域的限制，就只能在当前cpp里用，类本来就是为了给程序里各种地方用的，其他地方使用类是包含类的头文件，而无法包含类的源文件。
		- （5）为什么常量静态成员数据的初始化可以放在类内（注意：只有静态常量整型数据成员才可以在类中初始化）
			- static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,这样编译器就不必考虑类的函数里面第一个对static变量的’=’操作是赋值还是初始化了。 static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图初始化了。